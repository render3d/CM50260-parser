import computation.contextfreegrammar.*;
import computation.parser.*;
import computation.parsetree.*;
import computation.derivation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.util.Scanner;


public class Parser implements IParser {
  
  // ArrayList<WordsInCFG> currentwords = new ArrayList<WordsInCFG>(); // All words which can be generated up to n steps

  // *** PART C ***
  public boolean isInLanguage(ContextFreeGrammar cfg, Word w){
    /* 
      Input: An arbitrary context-free grammar G in Chomsky normal form together with a word w

      Output: A boolean value indicating whether or not w is in L(G) i.e. is generated by the grammar G 

      1. List all derivations in G with 2n − 1 steps, where n is the length of w, unless n = 0, in which case list all derivations with one step.

      2. If any of these derivations generate w, return true i.e. returns true if and only if the input word w is generated by input grammar cfg, which we assume is in Chomsky normal form. If not, return false.

      You should find some way of keeping track of the entire derivation from start variable to the final string. The Derivation class is there to help you do this. 

    */ 

    int n_w = w.toString().length();  // calculation of length, n, of the word, w
    int l_d = 2*n_w-1;                // calculation of derivation length in steps, l_d of word, w

    // Storing words method - purely for Part C

    System.out.println("\nn is equal to: " + n_w);
    System.out.println("2n-1 equals: " + l_d);

    List<Rule> rules = cfg.getRules();

    Variable start = cfg.getStartVariable();
    System.out.println("\nStart Variable (Variable): " + start);
    // System.out.println("Start Variable (String): " + start.toString());

    ArrayList<Word> currentwords = new ArrayList<Word>(); // All words which can be generated up to n steps

    currentwords.add(new Word(cfg.getStartVariable()));
    System.out.println("\nStarting Words List: " + currentwords);

    ArrayList<Variable> LHS = new ArrayList<Variable>();
    for (Rule rule : rules) {
      LHS.add(rule.getVariable());
    }
    // System.out.println("\nVariables List: (" + LHS.size() + ") " + LHS);

    ArrayList<Word> RHS = new ArrayList<Word>();
    for (Rule rule : rules) {
      RHS.add(rule.getExpansion());
    }
    // System.out.println("\nExpansions List: (" + RHS.size() + ") " + RHS);
    // System.out.println(" ");

    for (int steps = 0; steps < l_d; steps++) { // for 2n - 1 steps
    
    /*
      // there is a list of words to expand (currentwords) for which we we will take each one at a time

      // for each of these words we will traverse it from left to right, term by term, and expand the first varible we encounter i.e. the leftmost variable

      // to do this we will, for each word in the current words list:

        // get a word

        //split word into individual terms (terms can be variables or letters) then
            
          // for each term: read term 
            // if it is empty word
              // add empty word to list of new words
            // else
              // if it is NOT terminal
                // get all the rules that apply to the term (for loop)
                // get all expansions that apply to the term (for loop)
                // construct the list of new words whereby each new word equals current word but with the leftmost varible replaced (for loop)
                // break - to skip to next word in list of current words
              // else 
                // skip to next letter if it is already a terminal
        
        // set the list of new words as the list of current words for the next step of the expansion
    */

      System.out.println("\n *** STEP " + (steps+1) + " *** ");

      System.out.println("\nWords to expand: " + currentwords);
      
      ArrayList<Word> newwords = new ArrayList<Word>();

      for (int i = 0; i < currentwords.size(); i++) { // for each word, expand leftmost term

        if (currentwords.get(i).equals(new Word())){ // if it is the empty word
          // add empty word to accepted words list and move on to next word
          newwords.add(new Word()); 
        }
        else {
          Word lookup_exp = currentwords.get(i); // get word
          System.out.println("\nThis word: " + currentwords.get(i));

          ArrayList<Symbol> lookup_term = new ArrayList<Symbol>();

          for (int l = 0; l < lookup_exp.length(); l++) {
            lookup_term.add(lookup_exp.get(l));
          }

          // String[] lookup_term = lookup_exp.split(""); // split this word
          System.out.println("Terms in word: " + lookup_term);

          for (int t = 0; t < lookup_term.size(); t++) { // for each term: read term 
              
            ArrayList<Rule> relevant_rules = new ArrayList<Rule>();
            ArrayList<Word> relevant_expns = new ArrayList<Word>();

            // System.out.println(lookup_term.get(t).equals(new Word()));
            if (lookup_term.get(t).equals(new Word())) { // if it is empty word
              newwords.add(new Word());
            }
            else{ // if not empty word
              Word term_to_expand = new Word(lookup_term.get(t));

              if (!term_to_expand.isTerminal()) { // if it is NOT terminal

                // check variants
                for (int j = 0; j < LHS.size(); j++) { // find each relevant rule

                  Word compare_term = new Word(LHS.get(j)); // set lookup comparator in rule list
                  
                  if (term_to_expand.equals(compare_term)) { // lookup expansions and add to list of relevant rules

                    relevant_rules.add(rules.get(j));
                    
                  }
                  else {
                    // skip to next rule in list
                  }

                }

                System.out.println("Replacing " + term_to_expand + " using the following " + relevant_rules.size() + " expansion rules: " + relevant_rules);

                // contruct expansions list
                for (int rr = 0; rr < relevant_rules.size(); rr++) {
                  relevant_expns.add(relevant_rules.get(rr).getExpansion());
                }

                // System.out.println("Expansions: " + relevant_expns);

                // replace
                for (int nw = 0; nw < relevant_expns.size(); nw++) {
                  newwords.add(currentwords.get(i).replace(t,relevant_expns.get(nw)));
                }
                // System.out.println("New words: " + newwords);

                // break
                break; // stop expanding this word, skip to next word

              }
              else {
                // skip to next term in word
              }  
            }
            

          }
        }
      }

      // include terminal rules 
      for (Rule rule : rules) {
      
        if (( rule.getVariable() == cfg.getStartVariable() ) && ( rule.getExpansion().isTerminal()) ) {
          newwords.add(rule.getExpansion());
        }
          
      }

      currentwords = newwords;
      System.out.println("\nDerived words after step " + (steps+1) + ":\n" + currentwords);

    }

    //Check if w is in Language generated by cfg using the code above

    boolean accepted = false;

    // /* 
    //   if currentwords contains w
    //     return true
    //   else
    //     return false
    // */

    if (currentwords.contains(w)){
      accepted = true;
    }
    else {
      accepted = false;
    }

    System.out.println("\nThe word '" + w + "' is in the CFL: " + accepted);
    return accepted;
    
  }

  // *** PART D ***
  public ParseTreeNode generateParseTree(ContextFreeGrammar cfg, Word w) {
    /*
      Fill out this method so that it returns a parse tree whenever the input word w has a derivation in the input grammar cfg, and just null otherwise.

      Write a procedure which converts a valid derivation from Part C into a parse tree, working backwards through the steps you took. Your parse tree will be represented as an object of the ParseTreeNode class.

      In building your parse tree, you should work from the bottom of the tree upwards.
      
      First of all create a number of ParseTreeNode objects – one for each of the final terminals in the parse tree. You will also need to find a way to keep track of these objects.
      
      Then, by following the steps of the full derivation backwards, you can work out which ParseTreeNode objects need to be combined into new ParseTreeNodes. Eventually you’ll reach the start variable of the grammar, and this will be your final ParseTreeNode object.
      
      Note that iteration over objects of the Derivation class runs backwards by default (see the documentation for more details). To illustrate this, you could experiment with the printDerivation method.

    */

    // Storing derivations method - to help with Part D
    
    /* 
      for start variable (0) to derivation length
        declare new list nextwords for possible expansions
        for each string s in currentwords: 0 to 
          if string (currentwords.size()-1) contains expansion
            do expansion
            nextwords[s].add(expansion above)
          else
            nextwords.add(current string)
        currentwords = nextwords
    */
    
    /*
      Time constraints prevented part D from being dealt with in depth, however, had I had the time I would have sought to follow the procedure that follow:
        Adapt program in isInLanguage to store derivations of each word generated after 2n-1 steps as an array list.

        Lookup last element in list to match the input word (argument for isInLanguage and generateParseTree) to a derivation

        Generate parse tree using helper classes using the if else conditions below.
    */

    // if (isInLanguage(cfg, w)) {
    //   System.out.println("There exists some parse tree representing the derivation this word. Please refer to the comments made by the student in 'Parser.java'.");
    // }
    // else {
    //   return null;
    // }

    return null; // placeholder so program compiles
  }

  // AUXILIARY METHODS

  public void printDerivation(Derivation d) {
    // prints out all steps in the input derivation
    for(Step s : d) {
      System.out.println(s);
    }
  }

  // public void relevantRules () {

  // }

  // ACCESSORS AND MUTATORS

  // public List getRelevantRules () {
  //   return relevant_rules;
  // }

}